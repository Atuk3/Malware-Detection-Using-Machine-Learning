import json
import os
import io
from flask import Flask,render_template, request, jsonify,flash,url_for,redirect,session,make_response

from flask_wtf import FlaskForm
from wtforms import FileField, SubmitField
from werkzeug.utils import secure_filename
from wtforms.validators import InputRequired
import pefile
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import pickle
import math
import joblib
from sklearn.pipeline import Pipeline
import numpy as np
from io import BytesIO

import pefile
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import pickle
import math
import joblib
from sklearn.pipeline import Pipeline
import numpy as np
from io import BytesIO
from keras.applications import imagenet_utils
import tensorflow as tf 
import itertools
import pefile
import cv2
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from keras.utils import img_to_array
from PIL import Image


app=Flask(__name__)
app.config['SECRET_KEY']='david'
app.config['UPLOAD_FOLDER']='static/files'

allowed_extension="exe"



@app.route('/', methods=['GET', 'POST'])
@app.route('/home', methods=['GET', 'POST'])

def home():
    file_path=None
    error=None
    file_status=None
    prediction_accuracy=None
    file=None
    malware_family=None
    malware_behaviour=None
    if request.method == "POST":
        file=request.files['file']
        filename=file.filename
        if not filename.endswith('.exe'):
            flash('Invalid File Selected.. Choose a .exe file', category='error')
            return redirect(url_for('home'))
        
        
        data=file.read()
        pe = pefile.PE(data = data)
        img = None
        features,file_data= features_extraction(data, pe) 
        y_pred,pred_prob = getPredictions(file_data)
        if y_pred==0:
            file_status="Benign"
            file_comment="This file is safe"
            prediction_accuracy=(pred_prob[0][0])*100
            print(prediction_accuracy)
        
        if y_pred==1:
            file_status="Malware"
            file_comment="This file is harmful"
            prediction_accuracy=(pred_prob[0][1])*100
            print(prediction_accuracy)
            file.seek(0)
            image=createGreyScaleImage(file)
            img = cnn_predict(image)
            malware_family, malware_behaviour=get_malware_family(img)
            
            

            
        
        print(file_status)
        
       

        return render_template('report.html',filename=filename,file_status=file_status,file_comment=file_comment,features=features,prediction_accuracy=prediction_accuracy,malware_family=malware_family,malware_behaviour=malware_behaviour)
       
       
        
      
        
    
        

   
    return render_template('index.html')


  


@app.route('/about', methods=['GET', 'POST'])
def about():
    return render_template('about.html')

@app.route('/tutorial', methods=['GET', 'POST'])
def tutorial():
    return render_template('tutorial.html')



def features_extraction(data, pe):
     
      # File Header Features
      Machine=pe.FILE_HEADER.Machine
    
      TimeDateStamp=pe.FILE_HEADER.TimeDateStamp
      Characteristics=pe.FILE_HEADER.Characteristics
      SizeOfOptionalHeader = pe.FILE_HEADER.SizeOfOptionalHeader

      #DOS Header Features
      e_minalloc = pe.DOS_HEADER.e_minalloc
      e_lfanew = pe.DOS_HEADER.e_lfanew
      e_maxalloc = pe.DOS_HEADER.e_maxalloc

      # Optional Header Features
      Magic = pe.OPTIONAL_HEADER.Magic
      MajorLinkerVersion = pe.OPTIONAL_HEADER.MajorLinkerVersion
      ImageBase = pe.OPTIONAL_HEADER.ImageBase
      SectionAlignment = pe.OPTIONAL_HEADER.SectionAlignment
      MajorOSVersion = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
      MinorOSVersion = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
      MajorSubsystemVersion = pe.OPTIONAL_HEADER.MajorSubsystemVersion
      MinorSubsystemVersion = pe.OPTIONAL_HEADER.MinorSubsystemVersion
      Subsystem = pe.OPTIONAL_HEADER.Subsystem
      Dll = pe.OPTIONAL_HEADER.DllCharacteristics
      StackReserveSize = pe.OPTIONAL_HEADER.SizeOfStackReserve
      MajorImageVersion = pe.OPTIONAL_HEADER.MajorImageVersion
      SizeOfHeaders = pe.OPTIONAL_HEADER.SizeOfHeaders
      FileAlignment = pe.OPTIONAL_HEADER.FileAlignment

      
      # Suspicious Import Functions
      with open('suspicious_functions.txt') as f:
        content=f.readlines()
      content=[x.strip() for x in content]
      suspicious_imports = 0
      try:
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for func in entry.imports:
                    if func.name.decode('utf-8') in content:
                        suspicious_imports+=1
            SuspiciousImportFunctions =  suspicious_imports
      except AttributeError:
            SuspiciousImportFunctions=0



      # Section Features
      characteristics = map(lambda x:x.Characteristics, pe.sections)
      SectionMaxChar = max(characteristics)
      
      entropy = map(lambda x:x.get_entropy(), pe.sections)
      SectionMinEntropy = min(entropy)
    
      
      # Directory Features
      DirectoryEntryImport = (len(pe.DIRECTORY_ENTRY_IMPORT))
       
   
     
    
      
      #The important feature data of the file for the machine learning is stored in the file_data array
    
      file_data = [e_minalloc, e_lfanew, e_maxalloc, Machine, TimeDateStamp, Characteristics, SizeOfOptionalHeader, Magic, MajorLinkerVersion, ImageBase, SectionAlignment, MajorOSVersion, MinorOSVersion, MajorSubsystemVersion, MinorSubsystemVersion, Subsystem, Dll, StackReserveSize, MajorImageVersion, SizeOfHeaders, FileAlignment, SuspiciousImportFunctions, SectionMaxChar, SectionMinEntropy, DirectoryEntryImport]
      file_data = np.reshape(file_data,(1,-1))
      
      features={}

      #File size
      file_datum = io.BytesIO(data)
      features["size"] = len(file_datum.getvalue())
   
      api_calls=[]
      for entry in pe.DIRECTORY_ENTRY_IMPORT:
        api_calls.append(entry.dll.decode())
      features["api_calls"]= api_calls

    #   File extension
    
      file_extension=".exe"
      features["file_extension"] = file_extension
    


      # File entropy
    #   with open(file_path, "rb") as f:
    #     data = f.read()
    #     entropy = 0
    #     for b in range(256):
    #       p_b = float(data.count(bytes([b]))) / len(data)
    #       if p_b > 0:
    #           entropy += - p_b * math.log(p_b, 2)
    #     features["entropy"] = entropy
      
      return features,file_data

def getPredictions(data):
  model = joblib.load('Models/RFC_model.pkl')
  
  y_pred = model.predict(data)
  pred_prob= model.predict_proba(data)
  

  
  return y_pred,pred_prob




def getBinaryData(file):
        binary_values = []
        # read file byte by byte
        data = file.read(1)

        while data != b'':
          binary_values.append(ord(data))
          data = file.read(1)
        return binary_values


	

def createGreyScaleImage(filename, width=None):
    
    greyscale_data = getBinaryData(filename)
    size = get_size(len(greyscale_data), width)
    try:
        image = Image.new('L', size)
        image.putdata(greyscale_data)
        img_array=np.array(image)
        print("Image array")
        print(img_array)
        return img_array
    except Exception as err:
        print(err)
        print("Error creating GrayScale Image")
      

def get_size(data_length, width=None):
	# source Malware images: visualization and automatic classification by L. Nataraj
	# url : http://dl.acm.org/citation.cfm?id=2016908

	if width is None: # with don't specified any with value

		size = data_length

		if (size < 10240):
			width = 32
		elif (10240 <= size <= 10240 * 3):
			width = 64
		elif (10240 * 3 <= size <= 10240 * 6):
			width = 128
		elif (10240 * 6 <= size <= 10240 * 10):
			width = 256
		elif (10240 * 10 <= size <= 10240 * 20):
			width = 384
		elif (10240 * 20 <= size <= 10240 * 50):
			width = 512
		elif (10240 * 50 <= size <= 10240 * 100):
			width = 768
		else:
			width = 1024

		height = int(size / width) + 1

	else:
		width  = int(math.sqrt(data_length)) + 1
		height = width

	return (width, height)


#PreProcess
from io import BytesIO
from PIL import Image
model = None
output_dict = {'Adialer.C': 0,
 'Agent.FYI': 1,
 'Allaple.A': 2,
 'Allaple.L': 3,
 'Alueron.gen!J': 4,
 'Autorun.K': 5,
 'C2LOP.P': 6,
 'C2LOP.gen!g': 7,
 'Dialplatform.B': 8,
 'Dontovo.A': 9,
 'Fakerean': 10,
 'Instantaccess': 11,
 'Lolyda.AA1': 12,
 'Lolyda.AA2': 13,
 'Lolyda.AA3': 14,
 'Lolyda.AT': 15,
 'Malex.gen!J': 16,
 'Obfuscator.AD': 17,
 'Rbot!gen': 18,
 'Skintrim.N': 19,
 'Swizzor.gen!E': 20,
 'Swizzor.gen!I': 21,
 'VB.AT': 22,
 'Wintrim.BX': 23,
 'Yuner.A': 24}

def load_model():
  model =  tf.keras.models.load_model("Models/malware_classification_model.h5")
  print("Model loaded...")
  return model

def cnn_predict(image):
    global model
    if model is None:
        model = load_model()
     # Convert grayscale image to RGB image
    image = cv2.cvtColor(image, cv2.COLOR_GRAY2RGB)
    image = cv2.resize(image, (64, 64))
    image = img_to_array(image)
    print("Image Array")
    print(image)
    image = np.expand_dims(image, axis=0)
    res = model.predict(image)
    pred_class = np.argmax(res, axis=1)
    ax = model.predict(image)
    return get_key(pred_class)

def get_key(val):
    for key, value in output_dict.items():
         if val == value:
             return key
 
    return "key doesn't exist"

def get_malware_family(malware_name):
     if malware_name == 'Adialer.C' or malware_name == 'Dialplatform.B' or malware_name == 'Instantaccess':
        return ('Dialer', 'This is a dialer malware that dials premium-rate numbers without the user\'s consent.')
     elif malware_name == 'Agent.FYI' or malware_name == 'Rbot!gen':
        return ('Backdoor', 'This is a backdoor malware that allows attackers to gain remote access and control over the infected system.')
     elif malware_name == 'Allaple.A' or malware_name == 'Allaple.L' or malware_name == 'Autorun.K' or malware_name =='VB.AT' or malware_name =='Yuner.A':
        return ('Worm', 'This is a worm malware that spreads by creating copies of itself across the network and other computers.')
     elif malware_name == 'Alueron.gen!J'or malware_name == 'C2LOP.P' or malware_name == 'C2LOP.gen!g'or malware_name == 'Skintrim.N' or malware_name == 'Malex.gen!J':
        return ('Trojan', 'This is a Trojan malware that disguises itself as a legitimate software to trick the user into downloading and installing it.')
     elif malware_name == 'Dontovo.A'or malware_name =='Swizzor.gen!E' or malware_name=='Swizzor.gen!I' or malware_name == 'Obfuscator.AD' or malware_name =='Wintrim.BX':
        return ('Trojan Downloader', 'This is a Trojan downloader malware that downloads and installs additional malicious software onto the infected system.')
     elif malware_name == 'Lolyda.AA1' or malware_name == 'Lolyda.AT' or malware_name == 'Lolyda.AA3'or malware_name == 'Lolyda.AA2':
        return ('Keylogger', 'This is a keylogger malware that records keystrokes on the infected system and sends them to the attacker.')
     elif malware_name == 'Fakerean':
          return ('Rogue', 'This is a rogue malware that displays misleading or fake alerts to trick the user into purchasing a fake anti-virus software.')

     else:
        return 'Unknown malware family'

if __name__ == '__main__':
    app.run(debug=True)